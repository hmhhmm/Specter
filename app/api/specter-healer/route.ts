import { NextRequest, NextResponse } from "next/server";
import { Octokit } from "@octokit/core";
import { createPullRequest } from "octokit-plugin-create-pull-request";
import fs from "fs";
import path from "path";
import { HEALER_SCENARIOS } from "@/lib/specter-healer/scenarios";

const MyOctokit = Octokit.plugin(createPullRequest);

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { bugId, bugTitle, bugDescription, filePath: reqFilePath } = body;

    // 1. Resolve Scenario context
    const scenario = HEALER_SCENARIOS.find((s) => s.bugId === bugId);
    const title = bugTitle || scenario?.bugTitle || "Specter Healing Patch";
    const description = bugDescription || scenario?.bugDescription || "Automated fix for QA detected issue.";
    const filePath = reqFilePath || scenario?.filePath;

    if (!filePath) {
      return NextResponse.json({ error: "File path is required" }, { status: 400 });
    }

    // 2. Read current file content
    const fullPath = path.join(process.cwd(), filePath);
    if (!fs.existsSync(fullPath)) {
      return NextResponse.json({ error: `File not found: ${filePath}` }, { status: 404 });
    }
    const currentCode = fs.readFileSync(fullPath, "utf-8");

    // 3. Call NVIDIA NIM for the fix
    const nvidiaApiKey = process.env.NVIDIA_API_KEY;
    if (!nvidiaApiKey) {
      return NextResponse.json({ error: "NVIDIA_API_KEY missing" }, { status: 500 });
    }

    const systemPrompt = `You are a Senior Frontend Engineer at Specter.AI. 
Your task is to fix a bug in a React component detected by our QA agent.
You must return the ENTIRE corrected file content. 
DO NOT include any explanation or markdown commentary. 
ONLY return the code inside a single markdown code block.

Bug Title: ${title}
Bug Description: ${description}
${scenario ? `Fix Hint: ${scenario.fixHint}` : ""}

Ensure the fix is professional and follows the existing code style.`;

    const userPrompt = `Here is the current content of ${filePath}:

\`\`\`tsx
${currentCode}
\`\`\`

Please provide the full corrected version of this file.`;

    const response = await fetch("https://integrate.api.nvidia.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${nvidiaApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "meta/llama-3.3-70b-instruct",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt },
        ],
        temperature: 0.2,
        max_tokens: 4096,
      }),
    });

    if (!response.ok) {
      const errorData = await response.text();
      return NextResponse.json({ error: `LLM API failed: ${errorData}` }, { status: 500 });
    }

    const result = await response.json();
    const llmOutput = result.choices[0].message.content;

    // Extract code from markdown block
    const codeMatch = llmOutput.match(/```(?:tsx|jsx|typescript|javascript|)\n([\s\S]*?)```/) || 
                      llmOutput.match(/```([\s\S]*?)```/);
    const fixedCode = codeMatch ? codeMatch[1].trim() : llmOutput.trim();

    if (!fixedCode || fixedCode.length < 50) {
      return NextResponse.json({ error: "LLM returned invalid code" }, { status: 500 });
    }

    // 4. Create GitHub PR using Octokit
    const githubToken = process.env.GITHUB_TOKEN;
    const owner = process.env.GITHUB_OWNER;
    const repo = process.env.GITHUB_REPO || "Specter";

    if (!githubToken || !owner) {
      // For demo purposes, we return the diff even if GH is not configured
      return NextResponse.json({
        success: true,
        mocked: true,
        message: "GitHub not configured. Returning diff only.",
        prUrl: "#",
        codeBefore: currentCode,
        codeAfter: fixedCode,
        filePath,
      });
    }

    const octokit = new MyOctokit({ auth: githubToken });
    const branchName = `fix/specter-patch-${Date.now()}`;

    // Verify repository exists and get correct casing if needed
    let finalOwner = owner;
    let finalRepo = repo;
    
    try {
      const { data: repository } = await octokit.request("GET /repos/{owner}/{repo}", { owner, repo });
      finalOwner = repository.owner.login;
      finalRepo = repository.name;
    } catch (e) {
      console.warn(`[Healer API] Could not verify repo ${owner}/${repo}, proceeding with original values.`);
    }

    const prResponse = await octokit.createPullRequest({
      owner: finalOwner,
      repo: finalRepo,
      title: `[Specter Bot] Fix: ${title}`,
      body: `## ðŸ”® Specter Autonomous Healing
      
### Bug Report
- **Title:** ${title}
- **Description:** ${description}
- **Severity:** ${scenario?.severity || "P2"}

### Resolution
This PR was automatically generated by the Specter Healer agent using Llama 3.3 70B.

**Target File:** \`${filePath}\`

Please review the changes and merge if they meet requirements.`,
      head: branchName,
      base: "main",
      changes: [
        {
          files: {
            [filePath]: fixedCode,
          },
          commit: `fix: autonomously resolve ${title.toLowerCase()}`,
        },
      ],
    });

    if (!prResponse) {
        throw new Error("Failed to create pull request");
    }

    return NextResponse.json({
      success: true,
      prUrl: prResponse.data.html_url,
      prNumber: prResponse.data.number,
      codeBefore: currentCode,
      codeAfter: fixedCode,
      filePath,
      branchName,
    });

  } catch (error: any) {
    console.error("Healer API Error:", error);
    return NextResponse.json({ error: error.message || "Internal Server Error" }, { status: 500 });
  }
}
